use std::path::PathBuf;

use anyhow::{Context, Result};
use ics::{
    Event as IcsEvent, ICalendar, parameters,
    properties::{Description as IcsDescription, DtEnd, DtStart, Summary},
};
use rss::{ChannelBuilder, GuidBuilder, ItemBuilder};

use crate::{
    cli::{IcalCommand, RssCommand},
    storage::Storage,
};

use super::events::{DisplayZone, format_event_timing, parse_timezone, parse_utc};

pub fn generate_rss(storage: &Storage, cmd: RssCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(super::events::day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut items = Vec::new();
    for event in events {
        let summary = format_event_timing(&event, &zone)?;
        let mut description_parts = vec![summary];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        let description = description_parts.join("\n");
        let link = format!("toki-note://event/{}", event.id);
        let guid = GuidBuilder::default()
            .value(link.clone())
            .permalink(false)
            .build();
        let pub_date = parse_utc(&event.starts_at)?.to_rfc2822();
        let item = ItemBuilder::default()
            .title(Some(event.title.clone()))
            .description(Some(description))
            .link(Some(link.clone()))
            .pub_date(Some(pub_date))
            .guid(Some(guid))
            .build();
        items.push(item);
    }

    let title = cmd
        .title
        .unwrap_or_else(|| "toki-note schedule".to_string());
    let link = cmd.link.unwrap_or_else(|| "toki-note://events".to_string());
    let description = cmd
        .description
        .unwrap_or_else(|| "Personal schedule feed generated by toki-note".to_string());

    let channel = ChannelBuilder::default()
        .title(title)
        .link(link)
        .description(description)
        .items(items)
        .build();

    write_output(channel.to_string(), cmd.output)
}

pub fn generate_ical(storage: &Storage, cmd: IcalCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(super::events::day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut calendar = ICalendar::new("2.0", "toki-note");
    let mut emitted = false;
    for event in events {
        emitted = true;
        let uid = format!("{}@toki-note", event.id);
        let dtstamp = parse_utc(&event.starts_at)?
            .format("%Y%m%dT%H%M%SZ")
            .to_string();
        let mut vevent = IcsEvent::new(uid, dtstamp);

        if event.all_day {
            let start_day = event.starts_at[..10].to_string();
            let end_day = event.ends_at[..10].to_string();
            let mut start_prop = DtStart::new(start_day);
            start_prop.append(parameters!("VALUE" => "DATE"));
            let mut end_prop = DtEnd::new(end_day);
            end_prop.append(parameters!("VALUE" => "DATE"));
            vevent.push(start_prop);
            vevent.push(end_prop);
        } else {
            let (start_value, start_tz) = format_datetime_for_ics(&event.starts_at, &zone)?;
            let (end_value, end_tz) = format_datetime_for_ics(&event.ends_at, &zone)?;
            let mut start_prop = DtStart::new(start_value);
            if let Some(tz_name) = start_tz {
                start_prop.append(parameters!("TZID" => tz_name));
            }
            let mut end_prop = DtEnd::new(end_value);
            if let Some(tz_name) = end_tz {
                end_prop.append(parameters!("TZID" => tz_name));
            }
            vevent.push(start_prop);
            vevent.push(end_prop);
        }

        vevent.push(Summary::new(event.title.clone()));
        let mut description_parts = vec![format_event_timing(&event, &zone)?];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        vevent.push(IcsDescription::new(description_parts.join("\n")));

        calendar.add_event(vevent);
    }

    if !emitted {
        eprintln!("No events found; emitting empty calendar");
    }

    write_output(calendar.to_string(), cmd.output)
}

fn write_output(content: String, target: Option<PathBuf>) -> Result<()> {
    if let Some(path) = target {
        if let Some(parent) = path
            .parent()
            .filter(|parent| !parent.as_os_str().is_empty())
        {
            std::fs::create_dir_all(parent)
                .with_context(|| format!("failed to create {}", parent.display()))?;
        }
        std::fs::write(&path, content)
            .with_context(|| format!("failed to write {}", path.display()))?;
        eprintln!("Wrote {}", path.display());
    } else {
        print!("{}", content);
    }
    Ok(())
}

fn format_datetime_for_ics(value: &str, zone: &DisplayZone) -> Result<(String, Option<String>)> {
    let utc = parse_utc(value)?;
    match zone {
        DisplayZone::Local => Ok((utc.format("%Y%m%dT%H%M%SZ").to_string(), None)),
        DisplayZone::Named(tz) => {
            let localized = utc.with_timezone(tz);
            Ok((
                localized.format("%Y%m%dT%H%M%S").to_string(),
                Some(tz.to_string()),
            ))
        }
    }
}
