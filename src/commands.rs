use std::{fs, io::BufReader, path::PathBuf};

use anyhow::{Context, Result, anyhow};
use chrono::{DateTime, Duration, Local, NaiveDate, NaiveDateTime, TimeZone, Utc};
use chrono_tz::Tz;
use humantime::parse_duration;
use ical::property::Property as ParsedProperty;
use ical::{IcalParser, parser::ical::component::IcalEvent as ParsedIcalEvent};
use ics::{
    Event as IcsEvent, ICalendar, parameters,
    properties::{Description as IcsDescription, DtEnd, DtStart, Summary},
};
use rss::{ChannelBuilder, GuidBuilder, ItemBuilder};

use crate::{
    cli::{AddCommand, DeleteCommand, IcalCommand, ImportCommand, ListCommand, RssCommand},
    storage::{NewEvent, Storage, StoredEvent},
};

pub fn add_event(storage: &mut Storage, cmd: AddCommand) -> Result<()> {
    let timing = if cmd.all_day {
        if cmd.duration.is_some() {
            return Err(anyhow!("--duration cannot be used with --all-day"));
        }
        parse_all_day_range(&cmd)?
    } else {
        parse_timed_range(&cmd)?
    };

    let new_event = NewEvent {
        title: cmd.title,
        note: cmd.note.unwrap_or_default(),
        starts_at: timing.starts_at,
        ends_at: timing.ends_at,
        all_day: cmd.all_day,
        tags: cmd.tags,
        uid: None,
    };

    let row_id = storage.insert_event(new_event)?;
    println!("Stored event #{row_id}");
    Ok(())
}

pub fn list_events(storage: &Storage, cmd: ListCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let events = storage.fetch_events(range)?;
    let tz = parse_timezone(cmd.tz.as_deref())?;

    if events.is_empty() {
        println!("No events found");
        return Ok(());
    }

    for event in events {
        let timing = format_event_timing(&event, &tz)?;
        println!("#{} {}", event.id, event.title);
        println!("  {timing}");
        if !event.tags.is_empty() {
            println!("  tags: {}", event.tags.join(", "));
        }
        if !event.note.is_empty() {
            println!("  note: {}", event.note);
        }
        println!();
    }

    Ok(())
}

pub fn delete_event(storage: &mut Storage, cmd: DeleteCommand) -> Result<()> {
    match (cmd.id, cmd.title.as_deref()) {
        (Some(id), None) => {
            let removed = storage.delete_by_id(id)?;
            if removed {
                println!("Deleted event #{id}");
            } else {
                println!("No event found with id {id}");
            }
        }
        (None, Some(title)) => {
            let removed = storage.delete_by_title(title)?;
            if removed > 0 {
                println!("Deleted {removed} event(s) titled '{title}'");
            } else {
                println!("No events found titled '{title}'");
            }
        }
        (Some(id), Some(title)) => {
            let removed = storage.delete_by_id(id)?;
            if removed {
                println!("Deleted event #{id} titled '{title}'");
            } else {
                println!("No event #{id}; attempting title deletion");
                let removed = storage.delete_by_title(title)?;
                println!("Deleted {removed} event(s) titled '{title}'");
            }
        }
        (None, None) => {
            return Err(anyhow!("Provide either --id or --title"));
        }
    }
    Ok(())
}

pub fn generate_rss(storage: &Storage, cmd: RssCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut items = Vec::new();
    for event in events {
        let summary = format_event_timing(&event, &zone)?;
        let mut description_parts = vec![summary];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        let description = description_parts.join("\n");
        let link = format!("toki-note://event/{}", event.id);
        let guid = GuidBuilder::default()
            .value(link.clone())
            .permalink(false)
            .build();
        let pub_date = parse_utc(&event.starts_at)?.to_rfc2822();
        let item = ItemBuilder::default()
            .title(Some(event.title.clone()))
            .description(Some(description))
            .link(Some(link.clone()))
            .pub_date(Some(pub_date))
            .guid(Some(guid))
            .build();
        items.push(item);
    }

    let title = cmd
        .title
        .unwrap_or_else(|| "toki-note schedule".to_string());
    let link = cmd.link.unwrap_or_else(|| "toki-note://events".to_string());
    let description = cmd
        .description
        .unwrap_or_else(|| "Personal schedule feed generated by toki-note".to_string());

    let channel = ChannelBuilder::default()
        .title(title)
        .link(link)
        .description(description)
        .items(items)
        .build();

    write_output(channel.to_string(), cmd.output)
}

pub fn generate_ical(storage: &Storage, cmd: IcalCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut calendar = ICalendar::new("2.0", "toki-note");
    let mut emitted = false;
    for event in events {
        emitted = true;
        let uid = format!("{}@toki-note", event.id);
        let dtstamp = parse_utc(&event.starts_at)?
            .format("%Y%m%dT%H%M%SZ")
            .to_string();
        let mut vevent = IcsEvent::new(uid, dtstamp);

        if event.all_day {
            let start_day = event.starts_at[..10].to_string();
            let end_day = event.ends_at[..10].to_string();
            let mut start_prop = DtStart::new(start_day);
            start_prop.append(parameters!("VALUE" => "DATE"));
            let mut end_prop = DtEnd::new(end_day);
            end_prop.append(parameters!("VALUE" => "DATE"));
            vevent.push(start_prop);
            vevent.push(end_prop);
        } else {
            let (start_value, start_tz) = format_datetime_for_ics(&event.starts_at, &zone)?;
            let (end_value, end_tz) = format_datetime_for_ics(&event.ends_at, &zone)?;
            let mut start_prop = DtStart::new(start_value);
            if let Some(tz_name) = start_tz {
                start_prop.append(parameters!("TZID" => tz_name));
            }
            let mut end_prop = DtEnd::new(end_value);
            if let Some(tz_name) = end_tz {
                end_prop.append(parameters!("TZID" => tz_name));
            }
            vevent.push(start_prop);
            vevent.push(end_prop);
        }

        vevent.push(Summary::new(event.title.clone()));
        let mut description_parts = vec![format_event_timing(&event, &zone)?];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        vevent.push(IcsDescription::new(description_parts.join("\n")));

        calendar.add_event(vevent);
    }

    if !emitted {
        eprintln!("No events found; emitting empty calendar");
    }

    write_output(calendar.to_string(), cmd.output)
}

pub fn import_ics(storage: &mut Storage, cmd: ImportCommand) -> Result<()> {
    let path = cmd
        .path
        .as_ref()
        .ok_or_else(|| anyhow!("Provide --path or set import_source in config"))?;
    let file =
        fs::File::open(path).with_context(|| format!("failed to open {}", path.display()))?;
    let reader = BufReader::new(file);
    let parser = IcalParser::new(reader);

    let mut imported = 0usize;
    let mut skipped = 0usize;

    for calendar in parser {
        let calendar = calendar?;
        for event in calendar.events {
            match convert_ical_event(&event) {
                Ok(Some(new_event)) => {
                    if let Some(uid) = new_event.uid.as_deref() {
                        if storage.has_event_with_uid(uid)? {
                            skipped += 1;
                            continue;
                        }
                    }
                    storage.insert_event(new_event)?;
                    imported += 1;
                }
                Ok(None) => skipped += 1,
                Err(err) => {
                    skipped += 1;
                    eprintln!("Skipping event: {err}");
                }
            }
        }
    }

    println!("Imported {imported} event(s), skipped {skipped}");
    Ok(())
}

fn parse_all_day_range(cmd: &AddCommand) -> Result<EventTiming> {
    let start_date = parse_date(&cmd.start)?;
    let end_date = if let Some(end) = cmd.end.as_deref() {
        parse_date(end)?
    } else {
        start_date
    };

    let start_dt = start_date
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid start date"))?
        .and_utc();

    let end_dt = end_date
        .succ_opt()
        .ok_or_else(|| anyhow!("date overflow"))?
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid end date"))?
        .and_utc();

    Ok(EventTiming {
        starts_at: start_dt.to_rfc3339(),
        ends_at: end_dt.to_rfc3339(),
    })
}

fn parse_date(input: &str) -> Result<NaiveDate> {
    NaiveDate::parse_from_str(input, "%Y-%m-%d")
        .with_context(|| format!("expected YYYY-MM-DD date, got '{input}'"))
}

fn day_range(day: &str) -> Result<(String, String)> {
    let date = parse_date(day)?;
    let start = date
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid day"))?
        .and_utc();
    let end = date
        .succ_opt()
        .ok_or_else(|| anyhow!("date overflow"))?
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid day"))?
        .and_utc();
    Ok((start.to_rfc3339(), end.to_rfc3339()))
}

fn parse_timed_range(cmd: &AddCommand) -> Result<EventTiming> {
    let start_dt = DateTime::parse_from_rfc3339(&cmd.start)
        .with_context(|| format!("expected RFC3339 timestamp, got '{}'", cmd.start))?
        .with_timezone(&Utc);

    let end_dt = if let Some(end_value) = cmd.end.as_deref() {
        DateTime::parse_from_rfc3339(end_value)
            .with_context(|| format!("expected RFC3339 timestamp, got '{end_value}'"))?
            .with_timezone(&Utc)
    } else if let Some(duration_value) = cmd.duration.as_deref() {
        let parsed = parse_duration(duration_value)
            .with_context(|| format!("failed to parse duration '{duration_value}'"))?;
        let chrono_dur = chrono::Duration::from_std(parsed)
            .map_err(|_| anyhow!("duration '{duration_value}' is too large"))?;
        start_dt
            .checked_add_signed(chrono_dur)
            .ok_or_else(|| anyhow!("duration pushes end time out of range"))?
    } else {
        return Err(anyhow!(
            "provide either --end or --duration (or --all-day for date-based events)"
        ));
    };

    if end_dt <= start_dt {
        return Err(anyhow!("--end must be later than --start"));
    }

    Ok(EventTiming {
        starts_at: start_dt.to_rfc3339(),
        ends_at: end_dt.to_rfc3339(),
    })
}

fn format_event_timing(event: &StoredEvent, zone: &DisplayZone) -> Result<String> {
    let start_utc = parse_utc(&event.starts_at)?;
    let end_utc = parse_utc(&event.ends_at)?;
    match zone {
        DisplayZone::Local => {
            if event.all_day {
                let start = start_utc.with_timezone(&Local);
                let end = end_utc.with_timezone(&Local);
                let end_inclusive = end
                    .date_naive()
                    .pred_opt()
                    .unwrap_or_else(|| end.date_naive());
                Ok(format!(
                    "{} -> {} (all-day, local)",
                    start.date_naive(),
                    end_inclusive
                ))
            } else {
                let start = start_utc.with_timezone(&Local);
                let end = end_utc.with_timezone(&Local);
                Ok(format!(
                    "{} -> {} ({})",
                    start.format("%Y-%m-%d %H:%M %Z"),
                    end.format("%Y-%m-%d %H:%M %Z"),
                    start.offset()
                ))
            }
        }
        DisplayZone::Named(tz) => {
            if event.all_day {
                let start = start_utc.with_timezone(tz);
                let end = end_utc.with_timezone(tz);
                let end_inclusive = end
                    .date_naive()
                    .pred_opt()
                    .unwrap_or_else(|| end.date_naive());
                Ok(format!(
                    "{} -> {} (all-day, {})",
                    start.date_naive(),
                    end_inclusive,
                    tz
                ))
            } else {
                let start = start_utc.with_timezone(tz);
                let end = end_utc.with_timezone(tz);
                Ok(format!(
                    "{} -> {} ({})",
                    start.format("%Y-%m-%d %H:%M %Z"),
                    end.format("%Y-%m-%d %H:%M %Z"),
                    tz
                ))
            }
        }
    }
}

struct EventTiming {
    starts_at: String,
    ends_at: String,
}

fn parse_utc(value: &str) -> Result<DateTime<Utc>> {
    Ok(DateTime::parse_from_rfc3339(value)
        .with_context(|| format!("invalid timestamp '{value}'"))?
        .with_timezone(&Utc))
}

fn parse_timezone(input: Option<&str>) -> Result<DisplayZone> {
    if let Some(value) = input {
        let tz = value
            .parse::<Tz>()
            .map_err(|_| anyhow!("unknown timezone '{value}'"))?;
        Ok(DisplayZone::Named(tz))
    } else {
        Ok(DisplayZone::Local)
    }
}

fn format_datetime_for_ics(value: &str, zone: &DisplayZone) -> Result<(String, Option<String>)> {
    let utc = parse_utc(value)?;
    match zone {
        DisplayZone::Local => Ok((utc.format("%Y%m%dT%H%M%SZ").to_string(), None)),
        DisplayZone::Named(tz) => {
            let localized = utc.with_timezone(tz);
            Ok((
                localized.format("%Y%m%dT%H%M%S").to_string(),
                Some(tz.to_string()),
            ))
        }
    }
}

fn write_output(content: String, target: Option<PathBuf>) -> Result<()> {
    if let Some(path) = target {
        if let Some(parent) = path
            .parent()
            .filter(|parent| !parent.as_os_str().is_empty())
        {
            fs::create_dir_all(parent)
                .with_context(|| format!("failed to create {}", parent.display()))?;
        }
        fs::write(&path, content).with_context(|| format!("failed to write {}", path.display()))?;
        eprintln!("Wrote {}", path.display());
    } else {
        print!("{}", content);
    }
    Ok(())
}

fn convert_ical_event(event: &ParsedIcalEvent) -> Result<Option<NewEvent>> {
    let (starts_at, all_day) = match get_property(event, "DTSTART") {
        Some(prop) => parse_ics_datetime(prop)?,
        None => return Ok(None),
    };
    let ends_at = parse_ics_end(event, all_day, &starts_at)?;
    let title = get_property(event, "SUMMARY")
        .and_then(parse_text)
        .filter(|s| !s.is_empty())
        .unwrap_or_else(|| "Imported event".to_string());
    let note = get_property(event, "DESCRIPTION")
        .and_then(parse_text)
        .unwrap_or_default();
    let tags = get_property(event, "CATEGORIES")
        .and_then(parse_text)
        .map(|text| {
            text.split(',')
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
                .collect::<Vec<_>>()
        })
        .unwrap_or_default();
    let uid = get_property(event, "UID").and_then(parse_text);

    Ok(Some(NewEvent {
        title,
        note,
        starts_at: starts_at.to_rfc3339(),
        ends_at: ends_at.to_rfc3339(),
        all_day,
        tags,
        uid,
    }))
}

fn get_property<'a>(event: &'a ParsedIcalEvent, name: &str) -> Option<&'a ParsedProperty> {
    event
        .properties
        .iter()
        .find(|prop| prop.name.eq_ignore_ascii_case(name))
}

fn parse_text(prop: &ParsedProperty) -> Option<String> {
    prop.value.as_ref().map(|value| unescape_ics_text(value))
}

fn parse_ics_datetime(prop: &ParsedProperty) -> Result<(DateTime<Utc>, bool)> {
    let value = prop
        .value
        .as_ref()
        .ok_or_else(|| anyhow!("DTSTART missing value"))?;
    if is_all_day(prop) {
        let date = parse_date_value(value)?;
        let start = date
            .and_hms_opt(0, 0, 0)
            .ok_or_else(|| anyhow!("invalid start date"))?
            .and_utc();
        return Ok((start, true));
    }
    let tzid = property_param(prop, "TZID")
        .and_then(|vals| vals.get(0))
        .map(|s| s.as_str());
    let dt = parse_datetime_value(value, tzid)?;
    Ok((dt, false))
}

fn parse_ics_end(
    event: &ParsedIcalEvent,
    all_day: bool,
    start: &DateTime<Utc>,
) -> Result<DateTime<Utc>> {
    if let Some(prop) = get_property(event, "DTEND") {
        if all_day || is_all_day(prop) {
            let value = prop
                .value
                .as_ref()
                .ok_or_else(|| anyhow!("DTEND missing value"))?;
            let date = parse_date_value(value)?;
            let end = date
                .and_hms_opt(0, 0, 0)
                .ok_or_else(|| anyhow!("invalid end date"))?
                .and_utc();
            return Ok(end);
        } else {
            let tzid = property_param(prop, "TZID")
                .and_then(|vals| vals.get(0))
                .map(|s| s.as_str());
            let dt = parse_datetime_value(
                prop.value
                    .as_deref()
                    .ok_or_else(|| anyhow!("DTEND missing value"))?,
                tzid,
            )?;
            return Ok(dt);
        }
    }

    if all_day {
        Ok(*start + Duration::days(1))
    } else {
        Ok(*start + Duration::hours(1))
    }
}

fn parse_datetime_value(value: &str, tzid: Option<&str>) -> Result<DateTime<Utc>> {
    if let Some(stripped) = value.strip_suffix('Z') {
        let naive = NaiveDateTime::parse_from_str(stripped, "%Y%m%dT%H%M%S")?;
        return Ok(Utc.from_utc_datetime(&naive));
    }
    if let Some(zone) = tzid {
        let tz: Tz = zone
            .parse()
            .map_err(|_| anyhow!("unknown timezone '{zone}'"))?;
        let naive = NaiveDateTime::parse_from_str(value, "%Y%m%dT%H%M%S")?;
        let localized = tz
            .from_local_datetime(&naive)
            .single()
            .ok_or_else(|| anyhow!("ambiguous local time for {value} in {zone}"))?;
        return Ok(localized.with_timezone(&Utc));
    }
    let naive = NaiveDateTime::parse_from_str(value, "%Y%m%dT%H%M%S")?;
    Ok(Utc.from_utc_datetime(&naive))
}

fn parse_date_value(value: &str) -> Result<NaiveDate> {
    NaiveDate::parse_from_str(value, "%Y%m%d").with_context(|| format!("invalid date '{value}'"))
}

fn property_param<'a>(prop: &'a ParsedProperty, key: &str) -> Option<&'a Vec<String>> {
    prop.params.as_ref().and_then(|params| {
        params
            .iter()
            .find(|(name, _)| name.eq_ignore_ascii_case(key))
            .map(|(_, values)| values)
    })
}

fn is_all_day(prop: &ParsedProperty) -> bool {
    property_param(prop, "VALUE")
        .map(|vals| vals.iter().any(|v| v.eq_ignore_ascii_case("DATE")))
        .unwrap_or_else(|| prop.value.as_ref().map(|v| v.len() == 8).unwrap_or(false))
}

fn unescape_ics_text(value: &str) -> String {
    value
        .replace("\\\\", "\\")
        .replace("\\n", "\n")
        .replace("\\N", "\n")
        .replace("\\,", ",")
        .replace("\\;", ";")
}

enum DisplayZone {
    Local,
    Named(Tz),
}
