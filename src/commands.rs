use std::{fs, path::PathBuf};

use anyhow::{Context, Result, anyhow};
use chrono::{DateTime, Local, NaiveDate, Utc};
use chrono_tz::Tz;
use humantime::parse_duration;
use ics::{
    Event as IcsEvent, ICalendar, parameters,
    properties::{Description as IcsDescription, DtEnd, DtStart, Summary},
};
use rss::{ChannelBuilder, GuidBuilder, ItemBuilder};

use crate::{
    cli::{AddCommand, DeleteCommand, IcalCommand, ListCommand, RssCommand},
    storage::{NewEvent, Storage, StoredEvent},
};

pub fn add_event(storage: &mut Storage, cmd: AddCommand) -> Result<()> {
    let timing = if cmd.all_day {
        if cmd.duration.is_some() {
            return Err(anyhow!("--duration cannot be used with --all-day"));
        }
        parse_all_day_range(&cmd)?
    } else {
        parse_timed_range(&cmd)?
    };

    let new_event = NewEvent {
        title: cmd.title,
        note: cmd.note.unwrap_or_default(),
        starts_at: timing.starts_at,
        ends_at: timing.ends_at,
        all_day: cmd.all_day,
        tags: cmd.tags,
    };

    let row_id = storage.insert_event(new_event)?;
    println!("Stored event #{row_id}");
    Ok(())
}

pub fn list_events(storage: &Storage, cmd: ListCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let events = storage.fetch_events(range)?;
    let tz = parse_timezone(cmd.tz.as_deref())?;

    if events.is_empty() {
        println!("No events found");
        return Ok(());
    }

    for event in events {
        let timing = format_event_timing(&event, &tz)?;
        println!("#{} {}", event.id, event.title);
        println!("  {timing}");
        if !event.tags.is_empty() {
            println!("  tags: {}", event.tags.join(", "));
        }
        if !event.note.is_empty() {
            println!("  note: {}", event.note);
        }
        println!();
    }

    Ok(())
}

pub fn delete_event(storage: &mut Storage, cmd: DeleteCommand) -> Result<()> {
    let removed = storage.delete_event(cmd.id)?;
    if removed {
        println!("Deleted event #{}", cmd.id);
    } else {
        println!("No event found with id {}", cmd.id);
    }
    Ok(())
}

pub fn generate_rss(storage: &Storage, cmd: RssCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut items = Vec::new();
    for event in events {
        let summary = format_event_timing(&event, &zone)?;
        let mut description_parts = vec![summary];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        let description = description_parts.join("\n");
        let link = format!("toki-note://event/{}", event.id);
        let guid = GuidBuilder::default()
            .value(link.clone())
            .permalink(false)
            .build();
        let pub_date = parse_utc(&event.starts_at)?.to_rfc2822();
        let item = ItemBuilder::default()
            .title(Some(event.title.clone()))
            .description(Some(description))
            .link(Some(link.clone()))
            .pub_date(Some(pub_date))
            .guid(Some(guid))
            .build();
        items.push(item);
    }

    let title = cmd
        .title
        .unwrap_or_else(|| "toki-note schedule".to_string());
    let link = cmd.link.unwrap_or_else(|| "toki-note://events".to_string());
    let description = cmd
        .description
        .unwrap_or_else(|| "Personal schedule feed generated by toki-note".to_string());

    let channel = ChannelBuilder::default()
        .title(title)
        .link(link)
        .description(description)
        .items(items)
        .build();

    write_output(channel.to_string(), cmd.output)
}

pub fn generate_ical(storage: &Storage, cmd: IcalCommand) -> Result<()> {
    let range = if let Some(day) = cmd.day {
        Some(day_range(&day)?)
    } else {
        None
    };
    let zone = parse_timezone(cmd.tz.as_deref())?;
    let events = storage.fetch_events(range)?;

    let mut calendar = ICalendar::new("2.0", "toki-note");
    let mut emitted = false;
    for event in events {
        emitted = true;
        let uid = format!("{}@toki-note", event.id);
        let dtstamp = parse_utc(&event.starts_at)?
            .format("%Y%m%dT%H%M%SZ")
            .to_string();
        let mut vevent = IcsEvent::new(uid, dtstamp);

        if event.all_day {
            let start_day = event.starts_at[..10].to_string();
            let end_day = event.ends_at[..10].to_string();
            let mut start_prop = DtStart::new(start_day);
            start_prop.append(parameters!("VALUE" => "DATE"));
            let mut end_prop = DtEnd::new(end_day);
            end_prop.append(parameters!("VALUE" => "DATE"));
            vevent.push(start_prop);
            vevent.push(end_prop);
        } else {
            let (start_value, start_tz) = format_datetime_for_ics(&event.starts_at, &zone)?;
            let (end_value, end_tz) = format_datetime_for_ics(&event.ends_at, &zone)?;
            let mut start_prop = DtStart::new(start_value);
            if let Some(tz_name) = start_tz {
                start_prop.append(parameters!("TZID" => tz_name));
            }
            let mut end_prop = DtEnd::new(end_value);
            if let Some(tz_name) = end_tz {
                end_prop.append(parameters!("TZID" => tz_name));
            }
            vevent.push(start_prop);
            vevent.push(end_prop);
        }

        vevent.push(Summary::new(event.title.clone()));
        let mut description_parts = vec![format_event_timing(&event, &zone)?];
        if !event.note.is_empty() {
            description_parts.push(event.note.clone());
        }
        if !event.tags.is_empty() {
            description_parts.push(format!("tags: {}", event.tags.join(", ")));
        }
        vevent.push(IcsDescription::new(description_parts.join("\n")));

        calendar.add_event(vevent);
    }

    if !emitted {
        eprintln!("No events found; emitting empty calendar");
    }

    write_output(calendar.to_string(), cmd.output)
}

fn parse_all_day_range(cmd: &AddCommand) -> Result<EventTiming> {
    let start_date = parse_date(&cmd.start)?;
    let end_date = if let Some(end) = cmd.end.as_deref() {
        parse_date(end)?
    } else {
        start_date
    };

    let start_dt = start_date
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid start date"))?
        .and_utc();

    let end_dt = end_date
        .succ_opt()
        .ok_or_else(|| anyhow!("date overflow"))?
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid end date"))?
        .and_utc();

    Ok(EventTiming {
        starts_at: start_dt.to_rfc3339(),
        ends_at: end_dt.to_rfc3339(),
    })
}

fn parse_date(input: &str) -> Result<NaiveDate> {
    NaiveDate::parse_from_str(input, "%Y-%m-%d")
        .with_context(|| format!("expected YYYY-MM-DD date, got '{input}'"))
}

fn day_range(day: &str) -> Result<(String, String)> {
    let date = parse_date(day)?;
    let start = date
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid day"))?
        .and_utc();
    let end = date
        .succ_opt()
        .ok_or_else(|| anyhow!("date overflow"))?
        .and_hms_opt(0, 0, 0)
        .ok_or_else(|| anyhow!("invalid day"))?
        .and_utc();
    Ok((start.to_rfc3339(), end.to_rfc3339()))
}

fn parse_timed_range(cmd: &AddCommand) -> Result<EventTiming> {
    let start_dt = DateTime::parse_from_rfc3339(&cmd.start)
        .with_context(|| format!("expected RFC3339 timestamp, got '{}'", cmd.start))?
        .with_timezone(&Utc);

    let end_dt = if let Some(end_value) = cmd.end.as_deref() {
        DateTime::parse_from_rfc3339(end_value)
            .with_context(|| format!("expected RFC3339 timestamp, got '{end_value}'"))?
            .with_timezone(&Utc)
    } else if let Some(duration_value) = cmd.duration.as_deref() {
        let parsed = parse_duration(duration_value)
            .with_context(|| format!("failed to parse duration '{duration_value}'"))?;
        let chrono_dur = chrono::Duration::from_std(parsed)
            .map_err(|_| anyhow!("duration '{duration_value}' is too large"))?;
        start_dt
            .checked_add_signed(chrono_dur)
            .ok_or_else(|| anyhow!("duration pushes end time out of range"))?
    } else {
        return Err(anyhow!(
            "provide either --end or --duration (or --all-day for date-based events)"
        ));
    };

    if end_dt <= start_dt {
        return Err(anyhow!("--end must be later than --start"));
    }

    Ok(EventTiming {
        starts_at: start_dt.to_rfc3339(),
        ends_at: end_dt.to_rfc3339(),
    })
}

fn format_event_timing(event: &StoredEvent, zone: &DisplayZone) -> Result<String> {
    let start_utc = parse_utc(&event.starts_at)?;
    let end_utc = parse_utc(&event.ends_at)?;
    match zone {
        DisplayZone::Local => {
            if event.all_day {
                let start = start_utc.with_timezone(&Local);
                let end = end_utc.with_timezone(&Local);
                let end_inclusive = end
                    .date_naive()
                    .pred_opt()
                    .unwrap_or_else(|| end.date_naive());
                Ok(format!(
                    "{} -> {} (all-day, local)",
                    start.date_naive(),
                    end_inclusive
                ))
            } else {
                let start = start_utc.with_timezone(&Local);
                let end = end_utc.with_timezone(&Local);
                Ok(format!(
                    "{} -> {} ({})",
                    start.format("%Y-%m-%d %H:%M %Z"),
                    end.format("%Y-%m-%d %H:%M %Z"),
                    start.offset()
                ))
            }
        }
        DisplayZone::Named(tz) => {
            if event.all_day {
                let start = start_utc.with_timezone(tz);
                let end = end_utc.with_timezone(tz);
                let end_inclusive = end
                    .date_naive()
                    .pred_opt()
                    .unwrap_or_else(|| end.date_naive());
                Ok(format!(
                    "{} -> {} (all-day, {})",
                    start.date_naive(),
                    end_inclusive,
                    tz
                ))
            } else {
                let start = start_utc.with_timezone(tz);
                let end = end_utc.with_timezone(tz);
                Ok(format!(
                    "{} -> {} ({})",
                    start.format("%Y-%m-%d %H:%M %Z"),
                    end.format("%Y-%m-%d %H:%M %Z"),
                    tz
                ))
            }
        }
    }
}

struct EventTiming {
    starts_at: String,
    ends_at: String,
}

fn parse_utc(value: &str) -> Result<DateTime<Utc>> {
    Ok(DateTime::parse_from_rfc3339(value)
        .with_context(|| format!("invalid timestamp '{value}'"))?
        .with_timezone(&Utc))
}

fn parse_timezone(input: Option<&str>) -> Result<DisplayZone> {
    if let Some(value) = input {
        let tz = value
            .parse::<Tz>()
            .map_err(|_| anyhow!("unknown timezone '{value}'"))?;
        Ok(DisplayZone::Named(tz))
    } else {
        Ok(DisplayZone::Local)
    }
}

fn format_datetime_for_ics(value: &str, zone: &DisplayZone) -> Result<(String, Option<String>)> {
    let utc = parse_utc(value)?;
    match zone {
        DisplayZone::Local => Ok((utc.format("%Y%m%dT%H%M%SZ").to_string(), None)),
        DisplayZone::Named(tz) => {
            let localized = utc.with_timezone(tz);
            Ok((
                localized.format("%Y%m%dT%H%M%S").to_string(),
                Some(tz.to_string()),
            ))
        }
    }
}

fn write_output(content: String, target: Option<PathBuf>) -> Result<()> {
    if let Some(path) = target {
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                fs::create_dir_all(parent)
                    .with_context(|| format!("failed to create {}", parent.display()))?;
            }
        }
        fs::write(&path, content).with_context(|| format!("failed to write {}", path.display()))?;
        eprintln!("Wrote {}", path.display());
    } else {
        print!("{}", content);
    }
    Ok(())
}

enum DisplayZone {
    Local,
    Named(Tz),
}
